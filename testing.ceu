//*** #include's are no longer necessary

//*** SDL_Rect -> Rect
code/tight Collision (var& Rect r1, var& Rect r2) -> bool
do
  if r1.x+r1.w < r2.x then
    escape false;
  end
  if r1.y+r1.h < r2.y then
    escape false;
  end
  if r2.x+r2.w < r1.x then
    escape false;
  end
  if r2.y+ r2.h < r1.y then
    escape false;
  end
  escape true;
end

code/await Key_Is_Down (var int key) -> (var bool is_down) -> NEVER do
  is_down = false;
  loop do
    var int key1 = await KEY_PRESS   until (key1==key);
    is_down = true;
    var int key2 = await KEY_UNPRESS until (key2==key);
    is_down = false;
  end
end

//*** "ren" arguments are no longer necessary
code/await Ship (var int x, var int y) -> (var Rect rect, var int velx, var int vely, event bool collided) -> NEVER do
  rect = val Rect(x, y, 48, 60);      //*** TODO: GRAPHICS_GET_BMP_DIMENSIONS
  velx = 0;
  vely = 0;

  var& Key_Is_Down right = spawn Key_Is_Down(KEY_RIGHT);
  var& Key_Is_Down left  = spawn Key_Is_Down(KEY_LEFT);
  var& Key_Is_Down up    = spawn Key_Is_Down(KEY_UP);
  var& Key_Is_Down down  = spawn Key_Is_Down(KEY_DOWN);

  par do
    every 50ms do
      if right.is_down then
        velx = velx + 1;
      end
      if left.is_down then
        velx = velx - 1;
      end
      if down.is_down then        //*** Y-axis is (un)inverted
        vely = vely - 1;
      end
      if up.is_down then          //*** Y-axis is (un)inverted
        vely = vely + 1;
      end

      var int new_x = rect.x + velx;
      var int new_y = rect.y + vely;

      if new_x < -400+rect.w/2 then
        new_x = -400+rect.w/2;    //*** positions are center relative
      end
      if new_x > 400-rect.w/2 then
        new_x = 400-rect.w/2;
      end
      if new_y < -240+rect.h/2 then
        new_y = -240+rect.h/2;
      end
      if new_y > 240-rect.h/2 then
        new_y = 240-rect.h/2;
      end

      velx = new_x - rect.x;
      vely = new_y - rect.y;

      rect.x = new_x;
      rect.y = new_y;
    end
  with
    every FRAMES_REDRAW do
      emit GRAPHICS_DRAW_BMP(rect.x,rect.y, "res/logo-ship.bmp");   //*** pass path directly (currently no cache, possibly very slow)
    end
  with
    var bool is_green = await collided;
    loop do
      par/or do
        is_green = await collided;
      with
        watching 1s do
          every FRAMES_REDRAW do
            if is_green then
              emit GRAPHICS_DRAW_BMP(rect.x,rect.y, "res/logo-green-overlay.bmp");
            else
              emit GRAPHICS_DRAW_BMP(rect.x,rect.y, "res/logo-red-overlay.bmp");
            end
          end
        end
        await FOREVER;
      end
    end
  end
end

code/await Test_Case (var Point pst, var Color c) -> (var Rect rect, event void collided) -> void do
  rect = val Rect(pst.x, pst.y, _rand() % 2 * 40 + 40, 40);
  var int speed = _rand() % 4 + 4;

  par/or do
    await collided;
  with
    every 50ms do
      rect.x = rect.x - speed;
      if rect.x < -420 then
        break;
      end
    end
  with
    every FRAMES_REDRAW do
        emit GRAPHICS_SET_COLOR_RGB(c.r,c.g,c.b);               //*** SDL_SetRenderDrawColor -> GRAPHICS_SET_COLOR_RGB
        emit GRAPHICS_DRAW_RECT(rect.x,rect.y, rect.w,rect.h);  //*** SDL_RenderFillRect -> GRAPHICS_DRAW_RECT
    end
  end
end

code/await Green (var Point pst) -> (var& Rect rect, event& void collided) -> void do
  var&? Test_Case tst = spawn Test_Case(pst, Color(0x99,0xFF,0x99));
  watching tst do
    rect = &tst.rect;             // bind my public fields to corresponding fields in Test_Case
    collided = &tst.collided;
    await FOREVER;              // nothing else to do, behave just like Test_Case
  end
end

code/await Red (var Point pst) -> (var& Rect rect, event& void collided) -> void do
  var&? Test_Case tst = spawn Test_Case(pst, Color(0xFF,0x99,0x99));
  watching tst do
    rect = &tst.rect;
    collided = &tst.collided;
    await FOREVER;
  end
end

code/await Particle (var Rect rect, var int ship_velx, var int ship_vely, var Color c) -> void do
  var int velx = _rand() % 6 - 3 + ship_velx;
  var int vely = _rand() % 6 - 3 + ship_vely;

  par/or do
    every 250ms do
      if rect.w > 1 then
        rect.w = rect.w - 1;
        rect.h = rect.h - 1;
      else
        break;
      end
    end
  with
    every 50ms do
      if rect.x > -400+rect.w/2 and rect.x < 400-rect.w/2 and rect.y > -240+rect.h/2 and rect.y < 240-rect.h/2 then
        rect.x = rect.x + velx;
        rect.y = rect.y + vely;
      else
        break;
      end
    end
  with
    every FRAMES_REDRAW do
      emit GRAPHICS_SET_COLOR_RGB(c.r, c.g, c.b);
      emit GRAPHICS_DRAW_RECT(rect.x,rect.y, rect.w,rect.h);
    end
  end
end

code/await Score (void) -> (event void collided_green, event void collided_red) -> void do
  var int recentgreens = 0;
  var int recentreds = 0;

  par/or do
    every collided_green do
      recentgreens = recentgreens + 1;
    end
  with
    every collided_red do
      recentreds = recentreds + 1;
    end
  with
    await 10s;
    every 1s do
      if recentgreens > 0 then
        recentgreens = recentgreens - 1;
      else/if recentreds > 0 then
        recentreds = recentreds - 1;
      else
        break;
      end
    end
  with
    every FRAMES_REDRAW do
      var int i;
      loop i in [0->10[ do
        var Rect placement_circle = val Rect(200 + i*14, 50, 10,10);
        if i < recentgreens then
          emit GRAPHICS_SET_COLOR_NAME(COLOR_GREEN);
        else/if i < recentgreens + recentreds then
          emit GRAPHICS_SET_COLOR_NAME(COLOR_RED);
        else
          emit GRAPHICS_SET_COLOR_NAME(COLOR_GRAY);
        end
        emit GRAPHICS_DRAW_RECT(-195+i*14,185, 10,10);    //*** TODO: GRAPHICS_DRAW_CIRCLE
      end

      //*** draw text
      do
        var[4] _char str = _;
        _snprintf(&&str[0], 4, "%d", recentreds);
        emit GRAPHICS_SET_COLOR_NAME(COLOR_RED);
        emit GRAPHICS_DRAW_TEXT(370,220, &&str[0]);
      end
      do
        var[4] _char str = _;
        _snprintf(&&str[0], 4, "%d", recentgreens);
        emit GRAPHICS_SET_COLOR_NAME(COLOR_GREEN);
        emit GRAPHICS_DRAW_TEXT(370,190, &&str[0]);
      end
    end
  end
end

code/await Game (void) -> void do
  var&? Score score = spawn Score();

  watching score do
    pool[20] Green gs;
    pool[20] Red rs;

    par do
      every 40ms do
        spawn Green(Point((_rand() % 800) + 400, -240 + _rand() % 480)) in gs;
        spawn Red(Point((_rand() % 800) + 400, -240 + _rand() % 480)) in rs;
      end

    with
      var& Ship ship = spawn Ship(-300, 0);
      pool[] Particle ps;
      every FRAMES_UPDATE do    //*** SDL_DT -> FRAMES_UPDATE
        var&? Green green;
        loop green in gs do
          if (call Collision(&ship.rect, &green!.rect)) then
            emit green!.collided;
            emit ship.collided(true);
            emit score.collided_green;
            emit SOUND_PLAY("res/tele_toneup.wav");   //*** _Mix_PlayChannel -> SOUND_PLAY
            var int i;
            var int num_particles = _rand() % 25 + 10;
            loop i in [0->num_particles[ do
              var int sq = _rand() % 10 + 8;
              spawn Particle(Rect(green!.rect.x, green!.rect.y, sq, sq), ship.velx, ship.vely, Color(0x99, 0xFF, 0x99)) in ps;
            end
          end
        end
        var&? Red red;
        loop red in rs do
          if (call Collision(&ship.rect, &red!.rect)) then
            emit red!.collided;
            emit ship.collided(false);
            emit score.collided_red;
            emit SOUND_PLAY("res/tele_tonedown.wav");
            var int i;
            var int num_particles = _rand() % 25 + 10;
            loop i in [0->num_particles[ do
              var int sq = _rand() % 10 + 8;
              spawn Particle(Rect(red!.rect.x, red!.rect.y, sq, sq), ship.velx, ship.vely, Color(0xFF, 0x99, 0x99)) in ps;
            end
          end
        end
      end
    end
  end
end

//*** SDL_Init -> WINDOW_SET_TITLE/SET_SIZE
emit WINDOW_SET_TITLE("Red/Green Recurse/Center");
emit WINDOW_SET_SIZE(800,480,800,480);
emit GRAPHICS_SET_FONT("tiny.ttf", 30);

loop do
  // show splash screen
  emit GRAPHICS_DRAW_BMP(0,0, "res/splash.bmp");        //*** (0,0) is the screen center, x grows to left, y grows to top
  await KEY_PRESS;

  // show game
  emit WINDOW_SET_CLEAR_COLOR_RGB(0xFF,0xFF,0xFF);  //*** background color on FPS mode
  emit FRAMES_SET(yes);                             //*** switch to FPS mode
  await Game();

  // show lose screen
  emit FRAMES_SET(no);                      // switch to immediate mode
  emit GRAPHICS_DRAW_BMP(0,0, "res/lose.bmp");
  await 1s;
  await KEY_PRESS;
end   // loop

escape 0;
